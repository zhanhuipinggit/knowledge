# 动态规划（Dynamic Programming）简介

## 什么是动态规划？

动态规划（Dynamic Programming, DP）是一种通过将问题分解为更小的子问题，逐步求解并保存中间结果，从而避免重复计算的算法设计方法。它特别适用于以下两类问题：

1. **最优化问题**：寻找某种最优值（如最大值、最小值、最长路径等）。
2. **计数问题**：计算某种方案的总数（如不同路径的数量等）。

动态规划的核心思想是利用 **最优子结构** 和 **子问题重叠性**，避免了递归算法中的大量重复计算。

---

## 动态规划的特点

1. **最优子结构**
    - 一个问题的最优解可以由其子问题的最优解构成。
    - 如果问题不具有最优子结构，通常无法使用动态规划求解。

2. **子问题重叠性**
    - 不同子问题的解可能被多次重复计算。
    - 动态规划通过存储中间结果（通常使用数组或哈希表）来避免重复计算。

3. **状态转移方程**
    - 确定如何从一个状态转移到另一个状态，这是动态规划的核心。
    - 通过状态转移方程递推计算问题的解。

---

## 动态规划的基本步骤

1. **定义状态**
    - 用一个变量（通常是数组）表示问题的解。
    - 状态通常是问题的某个阶段的结果。

2. **状态转移方程**
    - 找到状态之间的递推关系。
    - 例如，对于斐波那契数列：`dp[i] = dp[i-1] + dp[i-2]`。

3. **初始化**
    - 根据问题的特点设置初始状态。
    - 例如，斐波那契数列的初始条件是 `dp[0] = 0` 和 `dp[1] = 1`。

4. **递推计算**
    - 从初始状态开始，根据状态转移方程逐步计算。

5. **返回结果**
    - 最后一个状态的值即为问题的解。

---

## 动态规划的分类

### 1. **线性动态规划**
- 问题的状态可以用一维或二维数组表示。
- **示例**：斐波那契数列、最长递增子序列。

### 2. **区间动态规划**
- 问题涉及一个区间，状态与区间的起点和终点相关。
- **示例**：矩阵链乘法、最长回文子序列。

### 3. **背包问题动态规划**
- 用于解决资源分配问题。
- **示例**：0-1 背包问题、完全背包问题。

### 4. **二维动态规划**
- 状态依赖于二维数组，常用于网格路径问题。
- **示例**：最短路径、最大路径和。

### 5. **树形动态规划**
- 用于树形结构中的问题。
- **示例**：树的直径、树上最大独立集。

### 6. **状态压缩动态规划**
- 用位运算压缩状态，通常用于解决组合问题。
- **示例**：旅行商问题（TSP）。

---

## 示例：斐波那契数列

**问题描述**：求第 `n` 个斐波那契数。

### 递归解法（有大量重复计算）：
```go
func fib(n int) int {
    if n <= 1 {
        return n
    }
    return fib(n-1) + fib(n-2)
}
```

### 动态规划解法：
```go
func fib(n int) int {
    if n <= 1 {
        return n
    }
    dp := make([]int, n+1)
    dp[0], dp[1] = 0, 1
    for i := 2; i <= n; i++ {
        dp[i] = dp[i-1] + dp[i-2]
    }
    return dp[n]
}
```

**优化：空间复杂度 O(1)**
```go
func fib(n int) int {
    if n <= 1 {
        return n
    }
    a, b := 0, 1
    for i := 2; i <= n; i++ {
        a, b = b, a+b
    }
    return b
}
```

---

## 动态规划的优缺点

### 优点
1. 避免了重复计算，大幅提升效率。
2. 提供了一种结构化的解题思路。

### 缺点
1. 对于状态和转移方程的设计要求较高。
2. 存储中间状态可能会导致较高的空间复杂度。

---

## 常见动态规划问题

1. **斐波那契数列**
2. **最长公共子序列**
3. **最长递增子序列**
4. **背包问题**
5. **矩阵路径问题**
6. **区间问题**（如最长回文子序列）
7. **旅行商问题**


