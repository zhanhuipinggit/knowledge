# 插入排序 (Insertion Sort)

## 1. 基本思想
插入排序的基本思想类似于扑克牌排序的方式：从左到右依次取出每个牌，插入到已排序部分的正确位置。这样，随着每一步的插入，排序过程就逐渐完成。

插入排序是一个**原地排序**算法，逐步将待排序的元素插入到已排序部分的合适位置，最终得到一个有序的序列。

## 2. 过程说明
假设我们有一组未排序的数字，我们从第二个元素开始，依次将每个元素插入到其前面已排序部分的合适位置。

## 3. 插入排序的步骤
1. 从第二个元素开始（索引1），将其与前面的元素进行比较。
2. 如果当前元素比前面的元素小，就将前面的元素后移一位，为当前元素腾出位置。
3. 继续比较当前元素与前面已排序部分的元素，直到找到合适的位置。
4. 重复以上步骤，直到整个序列排序完成。

## 4. 插入排序的示例

假设我们要对以下数组进行插入排序：
[5, 2, 9, 1, 5, 6]

我们将依次将每个元素插入到前面已排序部分的合适位置。每一步我们都会展示当前已排序部分和未排序部分。

| 步骤 | 当前数组        | 已排序部分 | 未排序部分 |
|------|-----------------|------------|------------|
| 初始 | [5, 2, 9, 1, 5, 6] |            | [5, 2, 9, 1, 5, 6] |
| 1    | [2, 5, 9, 1, 5, 6] | [5]        | [2, 9, 1, 5, 6] |
| 2    | [2, 5, 9, 1, 5, 6] | [2, 5]     | [9, 1, 5, 6] |
| 3    | [1, 2, 5, 9, 5, 6] | [2, 5, 9]  | [1, 5, 6] |
| 4    | [1, 2, 5, 5, 9, 6] | [2, 5, 9]  | [5, 6] |
| 5    | [1, 2, 5, 5, 6, 9] | [2, 5, 9]  | [6] |

在每一步中，当前数字被插入到了已经排序好的部分，从而使得已排序部分逐渐扩展，未排序部分缩小，最终完成排序。

## 5. 时间复杂度
- **最坏时间复杂度**：O(n²)，当数组是逆序时，每次插入都需要移动所有元素。
- **最好时间复杂度**：O(n)，当数组已经有序时，每次插入时不需要移动任何元素。
- **平均时间复杂度**：O(n²)，当数组是随机顺序时，平均每个元素需要移动n/2次。

## 6. 空间复杂度
- **空间复杂度**：O(1)，插入排序是原地排序算法，不需要额外的存储空间。

## 7. 稳定性
- **稳定性**：插入排序是稳定的。如果两个元素相等，插入排序不会改变它们的相对顺序。

## 8. 优缺点
- **优点**：
    - 算法简单，易于理解和实现。
    - 对于小规模或部分有序的序列，效率较高。
- **缺点**：
    - 当数据量较大时，时间复杂度为O(n²)，效率较低。

## 9. 插入排序的适用场景
- 数据量较小的情况。
- 数据部分有序时，插入排序表现良好。
- 当需要对流数据进行排序时，插入排序是一种高效的选择（因为它可以在插入时进行排序）。

## 总结
插入排序通过逐步将元素插入到已排序部分，形成逐渐扩大的有序序列。尽管它的时间复杂度较高，但在小规模或部分有序数据的情况下，仍然是一种非常实用的排序算法。

---

## 插入排序的图示

为了帮助更直观地理解插入排序的过程，我们可以用图形来表示每一轮排序的情况。

初始数组：
[5, 2, 9, 1, 5, 6]


- **步骤 1：插入 2**  
  比较 2 和 5，2 比 5 小，交换它们：
  [2, 5, 9, 1, 5, 6]

- **步骤 2：插入 9**  
  比较 9 和 5，9 比 5 大，无需交换，9 保持原位：
  [2, 5, 9, 1, 5, 6]

- **步骤 3：插入 1**  
  比较 1 和 9，1 比 9 小，交换位置；然后比较 1 和 5，1 比 5 小，再交换位置；最后比较 1 和 2，1 比 2 小，交换位置：
  [1, 2, 5, 9, 5, 6]

- **步骤 4：插入 5**  
  比较 5 和 9，5 比 9 小，交换位置；然后比较 5 和 5，发现相等，不交换：
[1, 2, 5, 5, 9, 6]


- **步骤 5：插入 6**  
  比较 6 和 9，6 比 9 小，交换位置；然后比较 6 和 5，6 比 5 大，无需交换：
[1, 2, 5, 5, 6, 9]


最终结果：
- [1, 2, 5, 5, 6, 9]

### 实现
- **go版本**
```go
func insertSort(nums []int) {
    for i := 1; i < len(nums); i++ {
        key := nums[i]  // 当前元素
        j := i - 1      // 比较的元素索引
        // 将大于 key 的元素向右移动一位
        for j >= 0 && nums[j] > key {
            nums[j+1] = nums[j]
            j--
        }
        // 插入当前元素到正确的位置
        nums[j+1] = key
	}
}

```

- **c++版本**
```cpp
#include <iostream>
#include <vector>
using namespace std;

void insertSort(vector<int>& nums) {
    for (int i = 1; i < nums.size(); i++) {
        int key = nums[i];  // 当前要插入的元素
        int j = i - 1;      // 用于比较的索引

        // 将大于 key 的元素向右移动一位
        while (j >= 0 && nums[j] > key) {
            nums[j + 1] = nums[j];
            j--;
        }
        // 插入当前元素到正确的位置
        nums[j + 1] = key;
    }
}

```

- **c版本**
```c
#include <stdio.h>
void insertSort(int nums[], int n) {
    
    for (int i = 1; i <n; i++) {
        int j = i-1;
        while ( j >= 0 && nums[j]> key) {
            nums[j+1] = nums[j];
            j--;
        }
        nums[j+1] = key;
    }

}


```