# 冒泡排序（Bubble Sort）

冒泡排序是一种基础的排序算法，因其排序过程中较大的元素逐步“冒泡”到数组的末尾而得名。它是一种简单直观但效率不高的算法，适用于小规模数据的排序。

---

## 算法特点

- **算法类别**：比较排序
- **时间复杂度**：
    - 最优时间复杂度：O(n)（数组已经有序时）
    - 最坏时间复杂度：O(n²)
    - 平均时间复杂度：O(n²)
- **空间复杂度**：O(1)（原地排序）
- **稳定性**：稳定排序（不会改变相同元素的相对顺序）

---

## 算法思想

冒泡排序通过重复遍历要排序的数组，每次比较相邻的两个元素，并根据大小关系交换它们的位置。每一轮遍历后，当前未排序部分中最大的元素会“冒泡”到数组的末尾。

重复该过程，直到数组完全有序。

---

## 算法步骤

1. 从数组的第一个元素开始，依次比较相邻的两个元素：
    - 如果第一个元素大于第二个元素，则交换它们的位置。
    - 如果第一个元素小于或等于第二个元素，不做操作。
2. 每次遍历会将当前未排序部分中最大的元素移动到数组末尾。
3. 重复上述步骤，逐渐缩小未排序部分的范围。
4. 当某次遍历中没有发生交换操作时，说明数组已经有序，排序结束。

---

## 示例代码

### **Python 实现**
```python
def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        # 提前退出标志位
        swapped = False
        for j in range(n - i - 1):
            if arr[j] > arr[j + 1]:
                # 交换相邻元素
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
                swapped = True
        # 如果没有交换，说明已排序
        if not swapped:
            break
    return arr

# 示例用法
array = [64, 34, 25, 12, 22, 11, 90]
print("排序前:", array)
print("排序后:", bubble_sort(array))
```

---

## 示例说明

假设排序数组为 `[64, 34, 25, 12, 22, 11, 90]`，以下是冒泡排序的执行过程：

### **初始状态**
`[64, 34, 25, 12, 22, 11, 90]`

### **第 1 轮遍历**

- 比较 64 和 34，交换位置：`[34, 64, 25, 12, 22, 11, 90]`
- 比较 64 和 25，交换位置：`[34, 25, 64, 12, 22, 11, 90]`
- 比较 64 和 12，交换位置：`[34, 25, 12, 64, 22, 11, 90]`
- 比较 64 和 22，交换位置：`[34, 25, 12, 22, 64, 11, 90]`
- 比较 64 和 11，交换位置：`[34, 25, 12, 22, 11, 64, 90]`
- 比较 64 和 90，不交换。

**第 1 轮结果**：`[34, 25, 12, 22, 11, 64, 90]`

### **第 2 轮遍历**

- 比较 34 和 25，交换位置：`[25, 34, 12, 22, 11, 64, 90]`
- 比较 34 和 12，交换位置：`[25, 12, 34, 22, 11, 64, 90]`
- 比较 34 和 22，交换位置：`[25, 12, 22, 34, 11, 64, 90]`
- 比较 34 和 11，交换位置：`[25, 12, 22, 11, 34, 64, 90]`
- 比较 34 和 64，不交换。

**第 2 轮结果**：`[25, 12, 22, 11, 34, 64, 90]`

### **第 3 轮遍历**

- 比较 25 和 12，交换位置：`[12, 25, 22, 11, 34, 64, 90]`
- 比较 25 和 22，交换位置：`[12, 22, 25, 11, 34, 64, 90]`
- 比较 25 和 11，交换位置：`[12, 22, 11, 25, 34, 64, 90]`

**第 3 轮结果**：`[12, 22, 11, 25, 34, 64, 90]`

### **第 4 轮遍历**

- 比较 12 和 22，不交换。
- 比较 22 和 11，交换位置：`[12, 11, 22, 25, 34, 64, 90]`

**第 4 轮结果**：`[12, 11, 22, 25, 34, 64, 90]`

### **第 5 轮遍历**

- 比较 12 和 11，交换位置：`[11, 12, 22, 25, 34, 64, 90]`

**第 5 轮结果**：`[11, 12, 22, 25, 34, 64, 90]`

**排序完成。**

---

## 优化点

1. **提前退出机制**
    - 如果在某一轮遍历中没有发生任何交换操作，则说明数组已经有序，可提前退出。

2. **减少比较次数**
    - 每轮遍历后，未排序部分的最后一个元素是最大的元素，无需再比较。

---

## 优缺点

### **优点**
1. 简单直观，容易实现。
2. 代码量少，适合初学者。

### **缺点**
1. 效率低，尤其是在大规模数据排序时。
2. 时间复杂度较高，不适合性能要求高的场景。

---

## 使用场景

冒泡排序适用于：
1. 数据规模较小，或者数据几乎有序的情况。
2. 学习排序算法的入门场景。

## 其它代码示例

**go**
```golang
func bubbleSort(nums []int) {
    for i := len(nums)-1; i > 0; i-- {
        for j := 0; j < i; j++ {
            if nums[j] > nums[j+1] {
                nums[j], nums[j+1] = nums[j+1], nums[j]
            }
        }
    }
}

```

**cpp**
```cpp
#include <iostream>
#include <vector>
using namespace std;
void bubbleSort(vector<int>& nums) {
    for (int i = nums.size()-1;i > 0; i--) {
        for (int j = 0; j < i; j++) {
            if (nums[j] > nums[j+1]) {
                int temp = nums[j];
                nums[j] = nums[j+1];
                nums[j+1] = temp;
            }
        }
    }
}

```

**c**
```c
include<stdio.h>
void bubbleSort(int *nums, int n) {
    for (int i = n -1; i > 0; i--) {
        for(int j = 0; j < i; j++) {
            if (nums[j] > nums[j+1]) {
                    int temp = nums[j];
                    nums[j] = nums[j+1];
                    nums[j+1] = temp;
                }
        }
    }
}

```

**rust**
```rust
fn bubble_sort(nums: &mut Vec<i32>) {
    for i in (1..nums.len()).rev() {
        for j in 0..i {
            if nums[j] > nums[j+1] {
                nums.swap(j,j+1);
            }
        }
    }

}
    
```


**java**
```java
public static void bubbleSort(int[] nums) {
    for (int i = nums.length-1; i > 0; i--) {
        for (int j = 0; j < i; j++ ) {
            if (nums[j] > nums[j+1]) {
                int temp  = nums[j];
                nums[j] = nums[j+1];
                nums[j+1] = temp;
            }
            
        }
    }
}


```

**python**
```python
def bubble_sort(nums):
    for i in range(len(nums)):
        swpped = False
        for j in range(0, len(nums)-i-1):
            if nums[j] > nums[j+1]:
                nums[j], nums[j+1] = nums[j+1], nums[j]
                swpped = True
        if not swpped:
            break

```
