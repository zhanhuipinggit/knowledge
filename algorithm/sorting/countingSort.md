# 计数排序（Counting Sort）

计数排序是一种线性时间复杂度的排序算法，适用于已知数据范围较小的场景。它的核心思想是通过统计每个元素出现的次数来确定它们在排序后数组中的位置。以下是计数排序的详细讲解。

## 算法特点
- **时间复杂度**: $O(n + k)$，其中 $n$ 是待排序数组的大小，$k$ 是数据范围（最大值与最小值的差加一）。
- **空间复杂度**: $O(n + k)$，需要额外的计数数组和输出数组。
- **稳定性**: 是一种稳定的排序算法，即具有相同值的元素在排序后相对位置保持不变。
- **限制**: 只能对非负整数或离散数据进行排序。如果有负数或浮点数，可以通过偏移和映射的方式处理。

## 算法步骤
1. **确定数据范围**:
   找出待排序数组中的最大值和最小值，以确定计数数组的大小。

2. **计数数组初始化**:
   创建一个大小为 $k = \text{max} - \text{min} + 1$ 的计数数组，将其全部初始化为 0。

3. **统计每个元素的出现次数**:
   遍历待排序数组，对每个元素进行计数，将其存入计数数组的对应位置。

4. **累加计数**:
   对计数数组进行累加，计算每个元素在排序后数组中的位置。

5. **输出排序结果**:
   倒序遍历待排序数组，根据计数数组的值，将元素放置到输出数组的正确位置，并更新计数数组。

6. **将结果复制回原数组（可选）**:
   如果需要原地排序，可以将排序结果复制回原数组。

## 示例代码
以下是 Python 实现的计数排序：

```python
def counting_sort(arr):
    # 确定数据范围
    min_val = min(arr)
    max_val = max(arr)
    range_val = max_val - min_val + 1

    # 创建计数数组并统计每个元素的出现次数
    count = [0] * range_val
    for num in arr:
        count[num - min_val] += 1

    # 累加计数数组
    for i in range(1, len(count)):
        count[i] += count[i - 1]

    # 创建输出数组
    output = [0] * len(arr)
    for num in reversed(arr):
        output[count[num - min_val] - 1] = num
        count[num - min_val] -= 1

    return output

# 示例用法
arr = [4, 2, 2, 8, 3, 3, 1]
sorted_arr = counting_sort(arr)
print("排序后:", sorted_arr)
```

## 示例解析
假设输入数组为 `[4, 2, 2, 8, 3, 3, 1]`，详细执行过程如下：

1. 确定数据范围：最小值 `1`，最大值 `8`，范围为 `8 - 1 + 1 = 8`。
2. 初始化计数数组：`[0, 0, 0, 0, 0, 0, 0, 0]`。
3. 统计元素次数：`[1, 0, 2, 2, 1, 0, 0, 1]`。
4. 累加计数数组：`[1, 1, 3, 5, 6, 6, 6, 7]`。
5. 倒序填充输出数组：`[1, 2, 2, 3, 3, 4, 8]`。
6. 排序完成。

## 应用场景
- 适用于整数范围较小的数据排序，例如考试成绩、年龄、分布在有限区间内的整数。
- 不适用于数据范围过大的场景，因为计数数组会占用大量内存。

## 优化与变种
- 如果数据分布非常稀疏，可以考虑使用散列表来代替计数数组。
- 对于小数或负数，可以通过适当的映射和偏移将其转换为非负整数进行排序。

## 小结
计数排序是一种高效、稳定的排序算法，但其局限性在于需要额外的内存来存储计数数组，因此适合用于特定场景。
