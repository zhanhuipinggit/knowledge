# 选择排序（Selection Sort）算法详解

选择排序是一种简单的排序算法。它的工作原理是每次从未排序的部分中选择最小的元素，然后将其与已排序部分的元素进行交换。虽然选择排序的效率较低，但它的实现非常简单，适合用于教学或理解排序算法的基本思想。

---

## 1. 选择排序的工作原理

选择排序的基本思路是：  
在每一轮中，通过扫描剩余的未排序部分，找到最小的元素，并将其放到已排序部分的末尾。每轮操作完成后，未排序的部分减少一个元素，已排序的部分增加一个元素，直到所有元素都排序完成。

### 选择排序的步骤：
1. 从数组的第一个元素开始，遍历整个数组，找到最小值。
2. 将找到的最小值与当前元素交换。
3. 将剩余未排序部分继续按相同方式排序，直到整个数组有序。

---

## 2. 选择排序的时间复杂度分析

选择排序的时间复杂度分析：
- **最坏情况时间复杂度**：`O(n^2)`（即每次都需要遍历剩余元素，比较次数是 `n(n-1)/2`）。
- **最好情况时间复杂度**：`O(n^2)`（无论数组初始状态如何，每次都要遍历剩余部分）。
- **平均情况时间复杂度**：`O(n^2)`。

选择排序的时间复杂度始终是 `O(n^2)`，因此它不适合处理大规模的数据集。

### 空间复杂度：
- **空间复杂度**：`O(1)`。选择排序是原地排序算法，不需要额外的存储空间。

---

## 3. 选择排序的优缺点

### 优点：
- **简单易理解**：选择排序的算法非常直观，容易理解和实现。
- **不需要额外空间**：选择排序是原地排序，空间复杂度是常数级别。

### 缺点：
- **效率低**：选择排序的时间复杂度为 `O(n^2)`，适用于数据量较小的情况。
- **不稳定排序**：选择排序在处理重复元素时可能会改变其相对顺序，因此它是一个不稳定排序算法。

---

## 4. 选择排序的运行过程

下面通过一个简单的例子来展示选择排序的运行过程。

假设我们有一个数组 `arr = [64, 25, 12, 22, 11]`，我们使用选择排序对它进行升序排序。

### 步骤 1：初始数组
`[64, 25, 12, 22, 11]`

### 步骤 2：第一次循环（寻找最小值并交换）
- 从数组中找出最小的元素（`11`），然后与第一个元素（`64`）交换。
`[11, 25, 12, 22, 64]`


### 步骤 3：第二次循环
- 在剩余的数组 `[25, 12, 22, 64]` 中找出最小的元素（`12`），然后与第二个元素（`25`）交换。
  `[11, 12, 25, 22, 64]`


### 步骤 4：第三次循环
- 在剩余的数组 `[25, 22, 64]` 中找出最小的元素（`22`），然后与第三个元素（`25`）交换。
  `[11, 12, 22, 25, 64]`


### 步骤 5：第四次循环
- 在剩余的数组 `[25, 64]` 中找出最小的元素（`25`），由于它已经在正确位置，因此不需要交换。
  `[11, 12, 22, 25, 64]`


### 步骤 6：第五次循环
- 最后一个元素 `64` 已经是排序好的，因此排序结束。
  `[11, 12, 22, 25, 64]`


---

## 5. 选择排序的图示

通过图表来展示每一步的交换过程，帮助理解选择排序的工作原理。

| 步骤   | 当前数组              | 最小值位置       | 交换后数组         |
|--------|-----------------------|------------------|---------------------|
| 初始   | `[64, 25, 12, 22, 11]` | -                | -                   |
| 步骤1  | `[64, 25, 12, 22, 11]` | 4 (最小值 `11`)  | `[11, 25, 12, 22, 64]` |
| 步骤2  | `[11, 25, 12, 22, 64]` | 2 (最小值 `12`)  | `[11, 12, 25, 22, 64]` |
| 步骤3  | `[11, 12, 25, 22, 64]` | 3 (最小值 `22`)  | `[11, 12, 22, 25, 64]` |
| 步骤4  | `[11, 12, 22, 25, 64]` | 3 (最小值 `25`)  | `[11, 12, 22, 25, 64]` |
| 步骤5  | `[11, 12, 22, 25, 64]` | 4 (最小值 `64`)  | `[11, 12, 22, 25, 64]` |

---

## 6. 总结

选择排序是一种非常简单且直观的排序算法，但由于其较低的时间复杂度（`O(n^2)`），它在数据量较大的时候效率较低。通常，它不适用于大规模数据的排序，但对于小规模数据或者需要原地排序的场景，它仍然是一个不错的选择。

选择排序的优缺点总结：
- **优点**：简单、实现容易，空间复杂度低，原地排序。
- **缺点**：时间复杂度高，效率低，适用场景有限。

对于大多数实际应用，选择排序通常会被更高效的排序算法（如快速排序、归并排序）所取代。

---



## 各版本实现
**go**
```golang
func selectSort(nums []int) {
  for i := 0 ; i < len(nums) -1; i++ {
    k := i
    for j := i+1; j < len(nums); j++ {
      if nums[j] < nums[k] {
          k = j
      }   
    }
	nums[k], nums[i] = nums[k], nums[i]
  }
	
}

```

**c++**
```cpp
#include <iostream>
#include <vector>
using namespace std;
void selectSort(vector<int>& nums) {
    for (int i = 0; i < nums.size() - 1; i++) {
        int k = i;  // 假设当前位置的元素为最小值
        for (int j = i + 1; j < nums.size(); j++) {  // 在未排序的部分中找到最小值
            if (nums[j] < nums[k]) {
                k = j;  // 更新最小值的索引
            }
        }
        // 每次都交换，不管是否有变化
        int temp = nums[k];
        nums[k] = nums[i];
        nums[i] = temp;
    }
}


```

**java**
```java
public static void selectSort(int[] nums) {
    // 外层循环遍历每个元素
    for (int i = 0; i < nums.length - 1; i++) {
        int k = i;  // 假设当前位置的元素为最小值
        // 内层循环遍历未排序部分
        for (int j = i + 1; j < nums.length; j++) {
            if (nums[j] < nums[k]) {
                k = j;  // 更新最小值的索引
            }
        }
        // 交换当前位置元素与最小值
        int temp = nums[k];
        nums[k] = nums[i];
        nums[i] = temp;
    }
}

```

**python**
```python
 
def select_sort(nums):
    # 外层循环遍历每个元素
    for i in range(len(nums) - 1):  # 不需要写成 range(0, len(nums) - 1)
        k = i  # 假设当前位置的元素是最小值
        # 内层循环查找最小值的索引
        for j in range(i + 1, len(nums)):
            if nums[j] < nums[k]:  # 找到更小的元素
                k = j
        # 交换最小值和当前位置元素
        nums[k], nums[i] = nums[i], nums[k]  # 直接交换，简化代码

 
```


**rust**
```rust
fn select_sort(nums: &mut [i32]) {
    let n = nums.len();
    for i in 0..n - 1 {
        let mut k = i;  // 假设当前位置是最小值
        for j in i + 1..n {
            if nums[j] < nums[k] {
                k = j;  // 更新最小值的索引
            }
        }
        // 交换最小值和当前位置的元素
        nums.swap(i, k);
    }
}

 
```

**c**
```c
#include <stdio.h>

void select_sort(int nums[], int n) {
    // 外层循环：遍历每个元素
    for (int i = 0; i < n - 1; i++) {
        int k = i;
        // 内层循环：在未排序部分查找最小元素
        for (int j = i + 1; j < n; j++) {
            if (nums[j] < nums[k]) {
                k = j;
            }
        }
        // 交换最小值和当前位置的元素
        int temp = nums[k];  // 声明临时变量
        nums[k] = nums[i];
        nums[i] = temp;
    }
}
 
```

**php**
```php
function selectSort(&$nums) {
    $n = count($nums);
    for ($i = 0; $i < $n - 1; $i++) {
        $k = $i;  // 假设当前位置的元素是最小值
        for ($j = $i + 1; $j < $n; $j++) {
            // 查找未排序部分中的最小值
            if ($nums[$j] < $nums[$k]) {
                $k = $j;  // 更新最小值的索引
            }
        }
        // 交换最小值和当前位置的元素
        $temp = $nums[$k];
        $nums[$k] = $nums[$i];
        $nums[$i] = $temp;
    }
}

```